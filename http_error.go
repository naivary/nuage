package nuage

import (
	"encoding/json"
	"fmt"
)

var (
	ErrJSONEncoding = &HTTPError{}
	ErrUnauthorized = &HTTPError{}
	ErrParamInvalid = &HTTPError{}
)

// HTTPError represents an error response formatted according to RFC 9457
// (Problem Details for HTTP APIs).
//
// It provides a machine-readable and human-readable description of an
// error that occurred while processing an HTTP request. It is serialized
// as JSON with the media type "application/problem+json".
type HTTPError struct {
	// Type is a URI reference that identifies the problem type.
	// When dereferenced, it may provide human-readable documentation for the error.
	// If empty, it defaults to "about:blank".
	Type string `json:"type,omitempty"`

	// Title is a short, human-readable summary of the problem type.
	// It should remain stable across occurrences of the problem.
	Title string `json:"title,omitempty"`

	// Status is the HTTP status code generated by the origin server
	// for this occurrence of the problem.
	Status int `json:"status,omitempty"`

	// Detail is a human-readable explanation specific to this occurrence
	// of the problem. It should help the client understand what went wrong
	// without exposing sensitive implementation details.
	Detail string `json:"detail,omitempty"`

	// Instance is a URI reference that identifies the specific occurrence
	// of the problem. It may be used for correlation, logging, or debugging.
	Instance string `json:"instance,omitempty"`

	// Extensions contains additional application-specific fields
	// beyond the standard RFC 9457 members. This can include any
	// extra metadata needed by the client or server.
	Extensions map[string]any `json:"-"`
}

func (e HTTPError) Error() string {
	return fmt.Sprintf("%s:%s", e.Type, e.Detail)
}

func (e HTTPError) MarshalJSON() ([]byte, error) {
	data := make(map[string]any)
	if e.Type != "" {
		data["type"] = e.Type
	} else {
		data["type"] = "about:blank"
	}
	if e.Title != "" {
		data["title"] = e.Title
	}
	if e.Status != 0 {
		data["status"] = e.Status
	}
	if e.Detail != "" {
		data["detail"] = e.Detail
	}
	if e.Instance != "" {
		data["instance"] = e.Instance
	}
	for k, v := range e.Extensions {
		// Ensure extensions do not overwrite standard fields
		if _, exists := data[k]; !exists {
			data[k] = v
		}
	}
	return json.Marshal(data)
}
