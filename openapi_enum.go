// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package nuage

import (
	"errors"
	"fmt"
)

const (
	LicenseKeywordMIT      LicenseKeyword = "MIT"
	LicenseKeywordApache20 LicenseKeyword = "Apache-2.0"
)

var ErrInvalidLicenseKeyword = errors.New("not a valid LicenseKeyword")

// String implements the Stringer interface.
func (x LicenseKeyword) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LicenseKeyword) IsValid() bool {
	_, err := ParseLicenseKeyword(string(x))
	return err == nil
}

var _LicenseKeywordValue = map[string]LicenseKeyword{
	"MIT":        LicenseKeywordMIT,
	"Apache-2.0": LicenseKeywordApache20,
}

// ParseLicenseKeyword attempts to convert a string to a LicenseKeyword.
func ParseLicenseKeyword(name string) (LicenseKeyword, error) {
	if x, ok := _LicenseKeywordValue[name]; ok {
		return x, nil
	}
	return LicenseKeyword(""), fmt.Errorf("%s is %w", name, ErrInvalidLicenseKeyword)
}

// MarshalText implements the text marshaller method.
func (x LicenseKeyword) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LicenseKeyword) UnmarshalText(text []byte) error {
	tmp, err := ParseLicenseKeyword(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *LicenseKeyword) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	ParamInPath   ParamIn = "path"
	ParamInQuery  ParamIn = "query"
	ParamInHeader ParamIn = "header"
	ParamInCookie ParamIn = "cookie"
)

var ErrInvalidParamIn = errors.New("not a valid ParamIn")

// String implements the Stringer interface.
func (x ParamIn) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ParamIn) IsValid() bool {
	_, err := ParseParamIn(string(x))
	return err == nil
}

var _ParamInValue = map[string]ParamIn{
	"path":   ParamInPath,
	"query":  ParamInQuery,
	"header": ParamInHeader,
	"cookie": ParamInCookie,
}

// ParseParamIn attempts to convert a string to a ParamIn.
func ParseParamIn(name string) (ParamIn, error) {
	if x, ok := _ParamInValue[name]; ok {
		return x, nil
	}
	return ParamIn(""), fmt.Errorf("%s is %w", name, ErrInvalidParamIn)
}

// MarshalText implements the text marshaller method.
func (x ParamIn) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ParamIn) UnmarshalText(text []byte) error {
	tmp, err := ParseParamIn(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ParamIn) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	SecurityTypeAPIKey        SecurityType = "APIKey"
	SecurityTypeHTTP          SecurityType = "HTTP"
	SecurityTypeMutualTLS     SecurityType = "MutualTLS"
	SecurityTypeOAuth2        SecurityType = "OAuth2"
	SecurityTypeOpenIDConnect SecurityType = "OpenIDConnect"
)

var ErrInvalidSecurityType = errors.New("not a valid SecurityType")

// String implements the Stringer interface.
func (x SecurityType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SecurityType) IsValid() bool {
	_, err := ParseSecurityType(string(x))
	return err == nil
}

var _SecurityTypeValue = map[string]SecurityType{
	"APIKey":        SecurityTypeAPIKey,
	"HTTP":          SecurityTypeHTTP,
	"MutualTLS":     SecurityTypeMutualTLS,
	"OAuth2":        SecurityTypeOAuth2,
	"OpenIDConnect": SecurityTypeOpenIDConnect,
}

// ParseSecurityType attempts to convert a string to a SecurityType.
func ParseSecurityType(name string) (SecurityType, error) {
	if x, ok := _SecurityTypeValue[name]; ok {
		return x, nil
	}
	return SecurityType(""), fmt.Errorf("%s is %w", name, ErrInvalidSecurityType)
}

// MarshalText implements the text marshaller method.
func (x SecurityType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SecurityType) UnmarshalText(text []byte) error {
	tmp, err := ParseSecurityType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SecurityType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	StyleMatrix     Style = "matrix"
	StyleLabel      Style = "label"
	StyleSimple     Style = "simple"
	StyleForm       Style = "form"
	StyleSpaceDelim Style = "spaceDelim"
	StylePipeDelim  Style = "pipeDelim"
	StyleDeepObject Style = "deepObject"
	StyleCookie     Style = "cookie"
)

var ErrInvalidStyle = errors.New("not a valid Style")

// String implements the Stringer interface.
func (x Style) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Style) IsValid() bool {
	_, err := ParseStyle(string(x))
	return err == nil
}

var _StyleValue = map[string]Style{
	"matrix":     StyleMatrix,
	"label":      StyleLabel,
	"simple":     StyleSimple,
	"form":       StyleForm,
	"spaceDelim": StyleSpaceDelim,
	"pipeDelim":  StylePipeDelim,
	"deepObject": StyleDeepObject,
	"cookie":     StyleCookie,
}

// ParseStyle attempts to convert a string to a Style.
func ParseStyle(name string) (Style, error) {
	if x, ok := _StyleValue[name]; ok {
		return x, nil
	}
	return Style(""), fmt.Errorf("%s is %w", name, ErrInvalidStyle)
}

// MarshalText implements the text marshaller method.
func (x Style) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Style) UnmarshalText(text []byte) error {
	tmp, err := ParseStyle(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Style) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
