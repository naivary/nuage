package nuage

import (
	"encoding/json"
	"fmt"
)

var (
	ErrParamValidationFailed = HTTPError[string, string]{}
	ErrFormatUnsupported     = HTTPError[string, string]{}
	ErrNuageInternal         = HTTPError[string, string]{}
)

// TODO: implement a function which is taking a http.REsponseWriter and can
// serialize the error message

// httpError is a private, unexported interface implemented by custom
// error types that represent an HTTP-related failure.
//
// By implementing this interface, various concrete instantiations of a
// generic HTTP error type (e.g., HTTPError[T]) can be checked
// for membership in the "HTTP error family" using a simple type assertion:
//
//	if _, ok := err.(httpError); ok {
//	    // Handle as a known HTTP error
//	}
//
// The embedded 'error' ensures that any type satisfying httpError
// also satisfies the built-in error interface.
type httpError interface {
	error
	// isHTTPError is a non-exported sentinel method that ensures this
	// interface can only be satisfied by types within this package,
	// preventing external packages from implementing it inadvertently.
	isHTTPError()
}

// ContentTypeHTTPError defines the standard media type used for representing HTTP API error
// responses in JSON format, as specified in RFC 9457: Problem Details for HTTP APIs.
const ContentTypeHTTPError = "application/problem+json"

var _ httpError = (*HTTPError[any, any])(nil)

// HTTPError represents an RFC 9457 "problem details" object, providing a
// standardized way to convey machine-readable error details in HTTP responses.
type HTTPError[T, E any] struct {
	// A URI reference that identifies the problem type.
	Type string `json:"type"`

	// A short, human-readable summary of the problem type.
	Title string `json:"title,omitempty"`

	// The HTTP status code generated by the origin server for
	// this occurrence of the problem.
	Status int `json:"status,omitempty"`

	// A human-readable explanation specific to this occurrence
	// of the problem.
	Detail string `json:"detail,omitempty"`

	// A URI reference that identifies the  specific occurrence of
	// the problem. It may or may not yield further information if
	// dereferenced.
	Instance string `json:"instance,omitempty"`

	// Errors is a custom field for structured error data, such as
	// a list of field validation errors. The type of each element
	// is defined by the generic parameter T
	Errors []T `json:"errors,omitempty"`

	// AdditionalMembers are custom members which will be included into the root
	// HTTPError JSON response.
	AdditionalMembers E `json:"-"`
}

func (h *HTTPError[T, E]) Error() string {
	return fmt.Sprintf("%d:%s", h.Status, h.Title)
}

// INFO: This might be a performance problem in the future because it unmarshals
// and marshals everything twice.
func (h *HTTPError[T, E]) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	httpErr := *h
	httpErrData, err := json.Marshal(httpErr)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(httpErrData, &m); err != nil {
		return nil, err
	}
	additionalMembersData, err := json.Marshal(httpErr.AdditionalMembers)
	if err != nil {
		return nil, err
	}
	if err := json.Unmarshal(additionalMembersData, &m); err != nil {
		return nil, err
	}
	return json.Marshal(&m)
}

func (h *HTTPError[T, E]) isHTTPError() {}
